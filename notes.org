#+title: Заметки
#+LANGUAGE: ru
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,fleqn,12pt]
#+LATEX_HEADER: \usepackage[lmargin=15mm, rmargin=15mm, tmargin=2cm, bmargin=2cm]{geometry}

* Представление данных
В общем виде задача ЛП имеет вид
\[
C^{T}[N] \cdot x[N] \to \min
\]
\begin{cases}
A[M_{1},N]\cdot x[N] \geq b[M_{1}]\\
A[M_{2},N] \cdot x[N] = b[M_{2}]\\
x[N_{1}] \geq 0
\end{cases}
** Чтение из файла.
1. В первой строчке размерность задачи: кол-во переменных и кол-во ограничений $m,n$
2. Строка в которой записаны разделённые запятой коэфициенты функции цели (предполагается минимизация)
3. $m$ строк, в которых $n$ разделённых запятой коэфициентов, одно из ={GT,LT,EQ}=, означающее $\ge,\le,=$, свободный член.
4. до $n$ индексов, означающие переменные без ограничения на знак
*** Пример
Пример в отчёт включать скорее всего не стоит, но про представление я бы написал, в частности то, что задачи в
канонической форме генерируются из общей

Задача (если пойдёт в отчёт, это будет с задачей, которую мы используем)
\[
x_{1} + x_{2} + x_{3} \to \min
\]
\begin{cases}
3x_{1} - 5x_{2} + x_{3} \geq 3\\
x_{1} + x_{2} - x_{3} \leq 5\\
8x_{1} + x_{2} + 5x_{3} = 11\\
x_{1} \geq 0 , x_{2} \geq 0
\end{cases}

Будет записана как
#+begin_src csv
3,3
1,1,1
3,-5,1,GT,3
1,1,-1,LT,5
8,1,5,EQ,11
3
#+end_src
** Предобработка
По общей форме задачи генерируется каноническая форма прямой задачи и общая \to каноническая форма двойственной задачи

Каноническая форма хранится в виде вектора коэфициентов функции цели, матрицы коэфициентов ограничений и столбца
свободных членов.
* Симплекс-метод
Решение СЛАУ и преобразование матриц к верхнетреугольному виду для облегчения вычисления определителя ("наивный"
рекурсивный алгоритм очевидно не подходит для задач большой размерности) использует метод отражений, так как он является
точным и уже был реализован в 3м семестре. При решении СЛАУ к ответу приходим, используя обратный ход метода Гаусса.
Матрица преобразований сохраняется для того, чтобы на последующих итерациях можно было не решать СЛАУ заново, перейти
простыми преобразованиями.
** Начальное приближение
Начальное приближение находится с помощью решения симплекс-методом вспомогательной задачи (метод иск. базиса)

Теория об этом. Последние пол страницы методички.
** Алгоритм симплекс-метода
1. Для начального приближения находим $N_{k}^{+}$, при необходимости $L_{k}^{+}$, $N_{k}$ (если $\abs{N_{k}} < n$).
   1. Решим уравнение $A[M,N_{k}] y_{k}[M] = C[N_{k}]$.\\
       Решение: $y_{k}^{T}[M] = C^{T}[N_{k}] \cdot B[N_{k},M]$, где $B[N_{k},M] = A^{-1}[M,N_{k}]$.
2. Вычисление $d^{T}_{k}[L_{k}] = C^{T}[N_{k}] - y_{k}^{T}[M] \cdot A[M,N]$
3. Построение $u_{k}[N]$
   1. Поиск $j_{k} \in L_{k}: d_{k}[j_{k}] < 0$. Если $j_{k}$ не найден, $d_{k}[L_{k}] \geq 0$, следовательно решение
      оптимальное. Иначе:
   2. $u_{k}[N_{k}] = B[N_{k},M]\cdot A[M,j_{k}], u_{k}[j_{k}] = -1$, по остальным индексам нули.
4. Построение $x_{k+1}$
   1. Найдём $P = \{i \in N| u_{k}[i] > 0\}$. Если $P = \emptyset$, целевая функция не ограничена снизу и алгоритм заканчивается.
   2. $\theta_{k} = \min_{P} \frac{x_{k}[i]}{u_{k}[i]} = \frac{x_{k}[i_{k}]}{u_{k}[i_{k}]}$
   3. $x_{k+1} = x_{k}[N] - \theta_{k}u_{k}[N]$.
5. Построение обратной матрицы. Есть два возможных случая:
   a. $\theta_k !=0$ . Тогда можем построить $B[N_{k+1},M]$ как
      \[
    B[N_{k+1},M] = F[N_{k+1},N_k]\cdot B[N_k,M]
    \]
        где матрица $F[N_{k+1},N_k]$ --- обратная к $G[N_k,N_{k+1}] = B[N_k,M]\cdot A[M,N_k+1]$. Матрица $G$ будет отличаться от
        единичной только столбцом, стоящим на $i_k$ -м месте.

        Этот столбец --- $u_k$. Очевидно $\det G [N_k,N_{k+1}] = u_k[i_k] > 0$, поэтому обратную матрицу очень легко
      найти
      #+begin_export latex
            \[
      F[N_{k+1},N_k] = \begin{pmatrix}
                           1 & \cdots & - u_k[1] / u_k[i_k] & \cdots & 0\\
                           \vdots & \ddots & . & . & \vdots\\
                           0 & . & 1 / u_k [i_k] & . & 0\\
                           \vdots & . & . & \ddots & \vdots\\
                           0 & \cdots & - u_k[m] / u_k[i_k] & \cdots & 1\\
      \end{pmatrix}
            \]
            \[
      B[N_{k+1},M] = F[N_{k+1},N_k] \cdot B[N_k,M] \quad y_{k+1}^T[M] = C^{T}[N_k] \cdot B[N_{k+1},M]
            \]
      #+end_export
        Исключим из $N_{k}, N_{k}^+ \ j_k$ и добавим туда $i_k$
   b.      Если $x_{k}[N]$ --- вырожденный опорный вектор, может получиться так, что $\theta_{k} = 0$, если $\exists i \in N_{k} \setminus
        N_{k}^{+}$. В таком случае пытаемся изменить базис $x_{k}[N]$.

        Используемый для перестановок базиса алгоритм меняет векторы не по одному, поэтому обратную матрицу
        сложнее построить. Для упрощения алгоритма (хотя это медленнее) в этом случае решается СЛАУ $A[M,N_{k+1}]
        y_{k+1}[M] = C[N_{k+1}]$, и обратная матрица получается как побочный эффект решения.
        После этого вернёмся на шаг 2 алгоритма.

Ещё раз перечислю возможные выходы из цикла:
1. $d_k[N] \geq 0$ (3.1) --- найдено оптимальное решение
2. $u_k[N] < 0$ (4.1) --- целевая функция не ограничена
3. при переходе к следующему базису в (4.2) можем перебрать все возможные комбинации индексов, которыми дополняем
   $N_k^+$. В таком случае программа также завершается.
* Перебор крайних точек
